#!/usr/bin/env bash

# Given JSON objects on stdin, and a file descriptor containing JSON objects as
# $1, combines those elements of each with matching pkg/mod/name. If no match is
# found in $1, a fallback is used

[[ -n "$1" ]] || {
    echo "tagAsts requires an argument for its tags"     >> /dev/stderr
    echo "For example, 'echo FOO | tagAsts <(echo BAR)'" >> /dev/stderr
    exit 1
}

[[ -n "$2" ]] || {
    echo "tagAsts requires a JSON object as its second argument"  >> /dev/stderr
    echo "This is used as a fallback, e.g. '{\"myField\":false}'" >> /dev/stderr
    exit 2
}

TYPE=$(echo "$2" | jq -r 'type') || {
    echo "Couldn't parse tagAst's second argument '$2' as JSON" >> /dev/stderr
    exit 3
}

[[ "x$TYPE" = "xobject" ]] || {
    echo "tagAsts 2nd argument '$2' has type '$TYPE'" >> /dev/stderr
    echo "It should be an object"                     >> /dev/stderr
    exit 4
}

FALLBACK="({\"name\":\$this.name,\"module\":\$this.module,\"package\":\$this.package} + $2)"

# Call the current AST $this, then loop over $tags
INPUT=".[] | . as \$this | \$tags + [$FALLBACK]"

# Select $tags matching $this
# shellcheck disable=SC2016
QUERY='map(select((.module == $this.module) and (.name == $this.name))) | .[0]'

# Combine matching $tags with $this
# shellcheck disable=SC2016
ACTION='. + $this'

jq --argfile tags "$1" "[$INPUT | $QUERY | $ACTION]"
